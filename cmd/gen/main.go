// +build ignore

package main

import (
	"html/template"
	"io/ioutil"
	"log"
	"os"
	"regexp"
	"strings"
	"time"
)

var paginatedTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated at {{ .Timestamp }}

package bitbucket

import (
	"context"
	"encoding/json"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// PagingApiService provides paging for all paginated APIs
type PagingApiService service

// pageGet fetches the previous or next page for APIs that page results
func (a *PagingApiService) pageGet(ctx context.Context, pageURL string, successPayload interface{}) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	if pageURL == "" {
		return nil, reportError("The page URL is empty which means there is no next or previous page")
	}

	localVarHeaderParams := make(map[string]string)
	localVarFormParams := url.Values{}
	localVarQueryParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, pageURL, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return localVarHttpResponse, err
	}

	return localVarHttpResponse, err
}{{ range .Paginated }}

// {{ .FuncName }} is used to get the next or previous page of {{ .StructName }}
func (a *PagingApiService) {{ .FuncName }}(ctx context.Context, pageURL string) ({{ .StructName }}, *http.Response, error) {
	var successPayload {{ .StructName }}

	resp, err := a.pageGet(ctx, pageURL, &successPayload)

	return successPayload, resp, err
}
{{- end }}
`))

type paginated struct {
	FuncName   string
	StructName string
}

func main() {
	paged := []paginated{}
	reg := regexp.MustCompile("type (?P<name>Paginated(\\w+)) struct")

	files, err := ioutil.ReadDir(".")
	if err != nil {
		log.Fatal(err)
	}

	f, err := os.Create("paging_api.go")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	for _, file := range files {
		if strings.Index(file.Name(), "paginated_") != 0 {
			continue
		}
		c, err := ioutil.ReadFile(file.Name())
		if err != nil {
			log.Fatal(err)
		}
		matches := reg.FindSubmatch(c)
		if len(matches) != 3 {
			log.Fatal("Expected to find three matches")
		}

		structName := string(reg.FindSubmatch(c)[1])
		funcName := strings.Replace(structName, "Paginated", "", 1) + "PageGet"

		paged = append(paged, paginated{
			FuncName:   funcName,
			StructName: structName,
		})
	}

	paginatedTemplate.Execute(f, struct {
		Timestamp time.Time
		Paginated []paginated
	}{
		Timestamp: time.Now(),
		Paginated: paged,
	})
}
